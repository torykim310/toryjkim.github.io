{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/merge-sort/","result":{"data":{"site":{"siteMetadata":{"title":"Tory","author":"[Tory]","siteUrl":"https://gatsby-starter-bee.netlify.com","comment":{"disqusShortName":"","utterances":"JaeYeopHan/gatsby-starter-bee"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"bf318fbd-5dc9-5401-8a33-005bcbb62f75","excerpt":"Jump to Merge Sort About Merge Sort 정렬된 두 리스트의 왼쪽 인덱스부터 차례대로 대소관계를 비교합니다. 그리고 비교된 값 중 작은 값 부터 새로운 리스트에 채워나가면 O(n)의 시간복잡도로 두 리스트를 하나의 리스트에 정렬시킬 수 있습니다. 이 방법을 활용해서 정렬되지 않은 하나의 리스트를 길이가 2 혹은…","html":"<h1 id=\"jump-to-merge-sort\" style=\"position:relative;\"><a href=\"#jump-to-merge-sort\" aria-label=\"jump to merge sort permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Jump to Merge Sort</h1>\n<h2 id=\"about-merge-sort\" style=\"position:relative;\"><a href=\"#about-merge-sort\" aria-label=\"about merge sort permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>About Merge Sort</h2>\n<p>정렬된 두 리스트의 왼쪽 인덱스부터 차례대로 대소관계를 비교합니다. 그리고 비교된 값 중 작은 값 부터 새로운 리스트에 채워나가면 O(n)의 시간복잡도로 두 리스트를 하나의 리스트에 정렬시킬 수 있습니다. 이 방법을 활용해서 정렬되지 않은 하나의 리스트를 길이가 2 혹은 1인 여러 개의 부분 리스트로 분할합니다. 나눠진 부분 리스트들 중에서 두 리스트씩 비교해 하나의 더 큰 정렬된 리스트를 만드는 과정을 반복하면 입력받은 리스트를 정렬할 수 있습니다.</p>\n<h2 id=\"process-of-merge-sort\" style=\"position:relative;\"><a href=\"#process-of-merge-sort\" aria-label=\"process of merge sort permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Process of Merge Sort</h2>\n<div style=\"text-align: center\"><img src=\"/a29c0dd0186d1f8cef3c5ebdedf3e5a3/Merge_sort.gif\" art=\"How to devide and conquer\" )=\"\"></div>\n<ol>\n<li>리스트를 두 부분의 리스트로 더 이상 나눌 수 없을 때까지 작게 나눕니다.(분할)</li>\n<li>길이가 1인 리스트(가장 작은 리스트)가 되면 두 개의 인접한 리스트를 선택해 대소 관계를 비교하고 하나의 정렬된 상태로 합병하여 임시 리스트에 저장합니다.(정복)</li>\n<li>임시 리스트에 저장된 값들을 원래 리스트에 할당합니다.(합병)</li>\n<li>가장 작은 리스트가 모두 합병되어 조금 더 커진 부분 리스트가 되면 다시 이 리스트들 끼리 1번 부터 3번까지 반복합니다.</li>\n</ol>\n<h2 id=\"time-complexity\" style=\"position:relative;\"><a href=\"#time-complexity\" aria-label=\"time complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Time Complexity</h2>\n<ul>\n<li>분할 과정: n-1 번 => O(n)</li>\n<li>정복 과정: n * log(n) 번 => O(NlogN)</li>\n<li>합병 과정: n-1 번 => O(n)</li>\n</ul>\n<p>알고리즘의 시간복잡도를 측정할 때 정확하게 적용하지 않았기 때문에 시간 복잡도가 왜 O(NlonN)인지 헷갈렸다.\n시간복잡도를 계산할 때는 알고리즘에서 가장 복잡한 시간을 정확하게 인지해야 한다.</p>\n<p>즉 분할과정과 합병과정 정복과정은 모두 별개로 실행되기 때문에 O(n)번은 모두 무시하고, 정복 과정을 살펴보면 아래 그림과 같이 logN의 깊이 만큼 N번을 비교해야 하기 때문에 시간 복잡도는 O(logN)이 된다.</p>\n<div style=\"text-align: center\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 594px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 49.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAA7CAAAOyAHvx6IKAAACsUlEQVQoz2P4//8/AyGwG6hGHkibW/mwGhm7C2mqazLw8PLC5S0tLRGK3cxUWN3MVdncLdSAWJ3N1UyFzd1Sg83NXA1Mg8QcDeXY3EyVWF1tzThi4zM51NXVhSUkJIRA+vn5+RlsbGwQBmb372IvnnWcLWfCHrbcCbvYyuaeYcvu28GWP3k/W2bXFrbMnu1sHdveseVO3MueN3EnC8hD6uoazFJSUizm5ubsdnZ2DKampggDc2ec+Jgz49j9nBnHH4Fw9rSjD3NnnniQM/0YkD7+CIgfpk/c+yB7+rF3eTOPz41vW8cACyYTExMOY2NjEI0wMGfGid1Azatzph/dCKQ3ZE0D0jNO7AEavjlv5skNuTOObUyfuH8NUGxH/swTJemTDzGkTj7CaGigBzYQ5DoUA9MmH1MtXHpX2S2h1iWhY6t+6fIHIkDDGAoX3+VL6t2jCxR3zplzQT1j2inVjGkn9TKnHVfImHyAwSehlNHE1JTDxMwE6GUbBiPLQAYjc19gGE4/9h9oOxAf/5817ch/oEsPZU7axwD09jyQXN6sk/+BwfA/fcJeMA0UW5IFNDChaRkzyEBzAwsGEyN3BiMroIEWPgwMKR3r4wpmHY8F0gkFM4+Hly+8YFw07xxDyfyzGoVzToVl9GyJL5x9Ii61Y0N80dzTYcXzzmmXL7rAkNy4gNHK0pLdStWW0djImRloICPYwLjm1S3AsJKPbVxZmTX1SAXQBbnZM89IAV2YDOLHNa1qKFpwRTquaUVtxqQDFXkzT2RWL7/Bte7LfwZNLR1eM10zSQtzV0UjiyAOY3N/UCwf/18473wKMKa/Aw0Beuvw/7y5l0yAkfEid+bJ/3mzT/3Pn306MWvKwf9AC/4DY/p7w7qHojeBMS0jpyALinFrGwtGI1tfBkNLdwYAHvQwlMkawSoAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Merge Big O\" title=\"Merge Big O\" src=\"/static/50cb203957b7fde08b74c2a011df150e/5fd3e/Merge_Big_O.png\" srcset=\"/static/50cb203957b7fde08b74c2a011df150e/5a46d/Merge_Big_O.png 300w,\n/static/50cb203957b7fde08b74c2a011df150e/5fd3e/Merge_Big_O.png 594w\" sizes=\"(max-width: 594px) 100vw, 594px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n    </span>\n    <cite><a href=\"https://www.weeklyps.com/entry/%EB%B3%91%ED%95%A9-%EC%A0%95%EB%A0%AC-Merge-sort\" target=\"_black\">Merge Big-O Image</a> by RiKang</cite>\n</div>\n<h2 id=\"code\" style=\"position:relative;\"><a href=\"#code\" aria-label=\"code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code</h2>\n<p>추후 작성 예정입니다.</p>","frontmatter":{"title":"Merge Sort","date":"April 05, 2021"}}},"pageContext":{"slug":"/algorithm/merge-sort/","previous":{"fields":{"slug":"/algorithm/binary-search/"},"frontmatter":{"title":"Binary Search","category":"algorithm","draft":false}},"next":{"fields":{"slug":"/Data Structure/binary-search-tree/"},"frontmatter":{"title":"Binary Search Tree","category":"Data Structure","draft":false}}}},"staticQueryHashes":[]}